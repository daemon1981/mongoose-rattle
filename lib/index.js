// Generated by CoffeeScript 1.5.0
(function() {
  var Schema, keystone, moment, mongoose, rattlePlugin;

  keystone = require('keystone');

  mongoose = keystone.mongoose;

  moment = require('moment');

  Schema = mongoose.Schema;

  module.exports = rattlePlugin = function(schema, options) {
    var CommentSchema;
    if (!options) {
      options = {};
    }
    if (!options.UserSchemaName) {
      options.UserSchemaName = 'User';
    }
    if (!options.UserIdType) {
      options.UserIdType = Schema.Types.ObjectId;
    }
    CommentSchema = new Schema({
      message: {
        type: String,
        required: true,
        max: 2000,
        min: 1
      },
      creator: {
        type: options.UserIdType,
        ref: options.UserSchemaName,
        required: true
      },
      likes: [
        {
          type: options.UserIdType,
          ref: options.UserSchemaName
        }
      ],
      likesCount: {
        type: Number,
        "default": 0
      },
      dateCreation: {
        type: Date
      },
      dateUpdate: {
        type: Date
      }
    });
    schema.add({
      creator: {
        type: options.UserIdType,
        ref: options.UserShcemaName,
        required: true
      },
      likes: [
        {
          type: options.UserIdType,
          ref: options.UserSchemaName
        }
      ],
      likesCount: {
        type: Number,
        "default": 0
      },
      comments: [CommentSchema],
      dateCreation: {
        type: Date
      },
      dateUpdate: {
        type: Date
      }
    });
    schema.pre("save", function(next) {
      if (this.isNew) {
        this.emit('objectCreation', this._id, this, this.creator);
        this.dateCreation = moment().toDate();
      }
      this.dateUpdate = moment().toDate();
      this.likesCount = this.likes.length;
      return next();
    });
    CommentSchema.pre("save", function(next) {
      this.likesCount = this.likes.length;
      return next();
    });
    /**
     * Get the list of rattles with limited amount of comments
     *
     * @param {Number} num - number of rattles
     * @param {Number} maxLastComments - number max of comments retrieved
     * @param {Object} options:
     *                   fromCreationDate: creation date from which we retrieve rattles
     *                   populate:         list of fields to populate (example: 'fieldName' or 'fieldName1 fieldName2')
     * @callback(err, rattles)
    */

    schema.statics.getList = function(num, maxLastComments, options, callback) {
      var fields, query;
      if ('function' === typeof options) {
        callback = options;
        options = {};
      }
      query = {};
      if (options.fromCreationDate) {
        query = {
          dateCreation: {
            $lt: options.fromCreationDate
          }
        };
      }
      fields = {
        text: 1,
        creator: 1,
        dateCreation: 1,
        dateUpdate: 1,
        likesCount: 1
      };
      if (maxLastComments > 0) {
        fields.comments = {
          $slice: [-maxLastComments, maxLastComments]
        };
      }
      query = this.find(query, fields).sort('-dateCreation').limit(num);
      if (options.populate) {
        query.populate(options.populate);
      }
      return query.exec(callback);
    };
    /**
     * Get the list of comments from a rattle id
     *
     * @param {Number} rattleId - id of the rattle
     * @param {Number} num - number of comments required
     * @param {Number} offsetFromEnd - offset from end of the list of comments
     * @callback(err, comments)
    */

    schema.statics.getListOfCommentsById = function(rattleId, num, offsetFromEnd, callback) {
      var self;
      self = this;
      return this.aggregate({
        $unwind: "$comments"
      }, {
        $group: {
          _id: '',
          count: {
            $sum: 1
          }
        }
      }, function(err, summary) {
        var diff, fields, limit, start;
        start = -num - offsetFromEnd;
        limit = num;
        if (summary[0].count < Math.abs(start)) {
          diff = Math.abs(start) - summary[0].count;
          start += diff;
          limit -= diff;
        }
        if (limit <= 0) {
          return callback(null, []);
        }
        fields = {
          comments: {
            $slice: [start, limit]
          }
        };
        return self.findById(rattleId, fields).exec(function(err, rattle) {
          if (err) {
            return callback(err);
          }
          return callback(null, rattle.comments);
        });
      });
    };
    /**
     * Emit an event
     *
     * @param {String} eventName - event name
     * @param {Number} targetId  - object to which the event occured
     * @param {Object} resource  - object from which the event occured
     * @param {Number} actor     - actor who triggered the event
    */

    schema.methods.emit = function(eventName, targetId, resource, actor) {
      if (options.emitter) {
        return options.emitter.emit(eventName, targetId, resource, actor);
      }
    };
    /**
     * Add a comment
     *
     * @param {Number} userId  - user id adding comment
     * @param {String} message - text message
     * @callback(err, updatedRattle)
    */

    schema.methods.addComment = function(userId, message, callback) {
      var comment, self;
      self = this;
      comment = {
        message: message,
        creator: userId,
        dateCreation: moment().toDate(),
        dateUpdate: moment().toDate()
      };
      this.comments.push(comment);
      this.save(function(err, updatedRattle) {
        if (err !== null) {
          return callback(err);
        }
        self.emit('addComment', comment._id, self, userId);
        return callback(err, updatedRattle);
      });
      return this.comments[this.comments.length - 1]._id;
    };
    /**
     * Add a reply to a comment
     *
     * @param {Number} userId    - user id replying to the comment
     * @param {Number} commentId - comment id on which the user reply
     * @param {String} message   - text message
     * @callback(err, updatedRattle)
    */

    schema.methods.addReplyToComment = function(userId, commentId, message, callback) {
      var comment, reply, self;
      comment = this.getComment(commentId);
      if (!comment) {
        return callback(new Error('Comment doesn\'t exist'));
      }
      self = this;
      reply = {
        message: message,
        creator: userId,
        dateCreation: moment().toDate(),
        dateUpdate: moment().toDate()
      };
      comment.comments.push(reply);
      this.save(function(err, updatedRattle) {
        if (err !== null) {
          return callback(err);
        }
        self.emit('addReplyToComment', reply._id, comment, userId);
        return callback(err, updatedRattle);
      });
      return comment.comments[comment.comments.length - 1]._id;
    };
    /**
     * Edit a comment
     *
     * @param {Number} userId    - user id editing the comment
     * @param {Number} commentId - comment id on which the user edit
     * @param {String} message   - text message
     * @callback(err, updatedRattle)
    */

    schema.methods.editComment = function(userId, commentId, message, callback) {
      var comment, self;
      comment = this.getComment(commentId);
      if (!comment) {
        return callback(new Error('Comment doesn\'t exist'));
      }
      if (String(comment.creator) !== String(userId)) {
        return callback(new Error('Only owner can edit comment'));
      }
      comment.message = message;
      comment.dateUpdate = moment().toDate();
      self = this;
      this.save(function(err, updatedRattle) {
        if (err !== null) {
          return callback(err);
        }
        self.emit('editComment', comment._id, self, userId);
        return callback(err, updatedRattle);
      });
      return this.comments[this.comments.length - 1]._id;
    };
    /**
     * Remove a comment
     *
     * @param {Number} userId    - user id removing the comment
     * @param {Number} commentId - comment id removed
     * @callback(err, updatedRattle)
    */

    schema.methods.removeComment = function(userId, commentId, callback) {
      var found, self;
      if (!this.getComment(commentId)) {
        return callback(new Error('Comment doesn\'t exist'));
      }
      found = false;
      this.comments = this.comments.filter(function(comment) {
        var keep;
        keep = String(comment.creator) !== String(userId) || String(comment._id) !== String(commentId);
        found = found || !keep;
        return keep;
      });
      if (!found) {
        return callback(new Error('Comment not found among creator\'s comments'), this);
      }
      self = this;
      return this.save(function(err, updatedRattle) {
        if (err !== null) {
          return callback(err);
        }
        self.emit('removeComment', self._id, self, userId);
        return callback(err, updatedRattle);
      });
    };
    /**
     * Like a rattle
     *
     * @param {Number} userId - user id liking
     * @callback(err, updatedRattle)
    */

    schema.methods.addLike = function(userId, callback) {
      var hasAlreadyLiked, self;
      hasAlreadyLiked = this.likes.some(function(likeUserId) {
        return String(likeUserId) === String(userId);
      });
      if (hasAlreadyLiked) {
        return callback(new Error('User has already liked this'), this);
      }
      this.likes.push(userId);
      self = this;
      return this.save(function(err, updatedRattle) {
        if (err !== null) {
          return callback(err);
        }
        self.emit('addLike', userId, self, userId);
        return callback(err, updatedRattle);
      });
    };
    /**
     * Like a comment
     *
     * @param {Number} userId    - user id liking
     * @param {Number} commentId - comment id to be liked
     * @callback(err, updatedRattle)
    */

    schema.methods.addLikeToComment = function(userId, commentId, callback) {
      var comment, hasAlreadyLiked, self;
      comment = this.getComment(commentId);
      if (!comment) {
        return callback(new Error('Comment doesn\'t exist'));
      }
      hasAlreadyLiked = comment.likes.some(function(likeUserId) {
        return String(likeUserId) === String(userId);
      });
      if (hasAlreadyLiked) {
        return callback(new Error('User has already liked this comment'), this);
      }
      comment.likes.push(userId);
      self = this;
      return this.save(function(err, updatedRattle) {
        if (err !== null) {
          return callback(err);
        }
        self.emit('addLikeToComment', commentId, self, userId);
        return callback(err, updatedRattle);
      });
    };
    /**
     * Unlike a rattle
     *
     * @param {Number} userId - user id unliking
     * @callback(err, updatedRattle)
    */

    schema.methods.removeLike = function(userId, callback) {
      var found, self;
      found = false;
      this.likes = this.likes.filter(function(likeUserId) {
        var keep;
        keep = String(likeUserId) !== String(userId);
        found = found || !keep;
        return keep;
      });
      if (!found) {
        return callback(new Error('User\'s like not found among document\'s likes'), this);
      }
      self = this;
      return this.save(function(err, updatedRattle) {
        if (err !== null) {
          return callback(err);
        }
        self.emit('removeLike', userId, self, userId);
        return callback(err, updatedRattle);
      });
    };
    /**
     * Unlike a comment
     *
     * @param {Number} userId    - user id unliking
     * @param {Number} commentId - comment id to be unliked
     * @callback(err, updatedRattle)
    */

    schema.methods.removeLikeFromComment = function(userId, commentId, callback) {
      var comment, found, self;
      comment = this.getComment(commentId);
      if (!comment) {
        return callback(new Error('Comment doesn\'t exist'));
      }
      found = false;
      comment.likes = comment.likes.filter(function(likeUserId) {
        var keep;
        keep = String(likeUserId) !== String(userId);
        found = found || !keep;
        return keep;
      });
      if (!found) {
        return callback(new Error('User\'s like not found among comment\'s likes'), this);
      }
      self = this;
      return this.save(function(err, updatedRattle) {
        if (err !== null) {
          return callback(err);
        }
        self.emit('removeLikeFromComment', commentId, self, userId);
        return callback(err, updatedRattle);
      });
    };
    /**
     * Get comment by id
     *
     * @param {Number} commentId - comment id to be retrieved
     * @return {Object} comment found
    */

    return schema.methods.getComment = function(commentId) {
      var comment, _i, _len, _ref;
      _ref = this.comments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        comment = _ref[_i];
        if (String(comment._id) === String(commentId)) {
          return comment;
        }
      }
      return null;
    };
  };

}).call(this);
